#!/usr/bin/env node
var minimist = require('minimist');
var extend = require('xtend');
var typings_1 = require('../typings');
var cli_1 = require('../utils/cli');
var config_1 = require('../utils/config');
var registry_1 = require('../lib/registry');
var cli_2 = require('../utils/cli');
var error_1 = require('../lib/error');
var args = minimist(process.argv.slice(2), {
    boolean: ['save', 'saveDev', 'ambient', 'verbose', 'help', 'production'],
    string: ['name', 'source'],
    alias: {
        save: ['S'],
        saveDev: ['save-dev', 'D'],
        name: ['n'],
        ambient: ['A'],
        verbose: ['v'],
        help: ['h'],
        source: ['s'],
        production: ['p']
    }
});
if (args.help) {
    console.log("\n" + config_1.PROJECT_NAME + " install (with no arguments, in package directory)\n" + config_1.PROJECT_NAME + " install <pkg>[@<version>] [ --source [" + Object.keys(registry_1.VALID_SOURCES).join(' | ') + "] ]\n" + config_1.PROJECT_NAME + " install file:<path>\n" + config_1.PROJECT_NAME + " install github:<github username>/<github project>[/<path>][#<commit>]\n" + config_1.PROJECT_NAME + " install bitbucket:<bitbucket username>/<bitbucket project>[/<path>][#<commit>]\n" + config_1.PROJECT_NAME + " install <http:// url>\n\nAliases: i, in\nOptions: [--name] [--save|--save-dev] [--ambient] [--production]\n");
    process.exit(0);
}
function installer(args) {
    var cwd = process.cwd();
    var verbose = args.verbose, save = args.save, saveDev = args.saveDev, name = args.name, ambient = args.ambient, source = args.source, production = args.production;
    var options = { save: save, saveDev: saveDev, name: name, ambient: ambient, cwd: cwd, production: production };
    if (!args._.length) {
        return cli_1.loader(typings_1.install(options), args)
            .then(function (tree) {
            console.log(cli_2.archifyDependencyTree(tree));
        });
    }
    var dependency = args._[0];
    if (!registry_1.isRegistryPath(dependency)) {
        return cli_1.loader(typings_1.installDependency(dependency, options), args)
            .then(function (tree) {
            console.log(cli_2.archifyDependencyTree(tree, { name: name }));
        });
    }
    var _a = registry_1.parseRegistryPath(dependency), dependencyName = _a.name, version = _a.version;
    function installFrom(source) {
        var saveName = name || dependencyName;
        var sourceName = registry_1.VALID_SOURCES[source];
        return registry_1.getVersions(source, dependencyName, version)
            .then(function (project) {
            var versions = project.versions;
            if (versions.length === 1) {
                return versions[0];
            }
            return cli_1.inquire([{
                    name: 'version',
                    type: 'list',
                    message: 'Select a version',
                    choices: versions.map(function (x, i) {
                        var version = x.version, compiler = x.compiler;
                        return {
                            name: version + (compiler ? " (TypeScript >= " + compiler + ")" : ''),
                            value: String(i)
                        };
                    })
                }])
                .then(function (answers) { return versions[answers.version]; });
        })
            .then(function (version) {
            var installOptions = extend(options, { name: saveName });
            var installation = typings_1.installDependency(version.location, installOptions);
            console.log("Installing " + dependencyName + "@" + version.version + " for " + sourceName + "...");
            if (name != null && name !== saveName) {
                console.log("Writing dependency as \"" + saveName + "\"...");
            }
            return cli_1.loader(installation, args);
        })
            .then(function (tree) {
            console.log(cli_2.archifyDependencyTree(tree, { name: saveName }));
        });
    }
    if (args.source) {
        return installFrom(args.source);
    }
    return cli_1.loader(registry_1.search({ name: dependencyName }), { verbose: verbose })
        .then(function (result) {
        var results = result.results;
        if (results.length === 0) {
            return Promise.reject(new error_1.default(("Unable to find \"" + dependencyName + "\" in the registry. If you can contribute ") +
                "this typing, please help us out: https://github.com/typings/registry"));
        }
        if (results.length === 1) {
            var item = results[0];
            var source_1 = registry_1.VALID_SOURCES[item.source];
            return cli_1.inquire([{
                    type: 'confirm',
                    name: 'ok',
                    message: "Found typings for " + dependencyName + " in " + source_1 + ". Ok?"
                }])
                .then(function (answers) {
                if (answers.ok) {
                    return installFrom(item.source);
                }
            });
        }
        return cli_1.inquire([{
                type: 'list',
                name: 'source',
                message: "Found typings for " + dependencyName + " in multiple registries",
                choices: results.map(function (result) {
                    return {
                        name: registry_1.VALID_SOURCES[result.source],
                        value: result.source
                    };
                })
            }])
            .then(function (answers) { return installFrom(answers.source); });
    })
        .catch(function (err) { return cli_2.handleError(err, { verbose: verbose }); });
}
installer(args);
//# sourceMappingURL=typings-install.js.map